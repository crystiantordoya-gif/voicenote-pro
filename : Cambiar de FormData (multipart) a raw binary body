[1mdiff --git a/pwa/src/components/Recorder.tsx b/pwa/src/components/Recorder.tsx[m
[1mindex 4b439e8..3f53ce4 100644[m
[1m--- a/pwa/src/components/Recorder.tsx[m
[1m+++ b/pwa/src/components/Recorder.tsx[m
[36m@@ -64,6 +64,7 @@[m [mexport const Recorder: React.FC = () => {[m
                 try {[m
                     await n8nService.uploadRecording(audioBlob, title, protagonist, language, priority);[m
                     alert('Grabaci√≥n subida exitosamente!');[m
[32m+[m[32m                    await storage.deleteRecording(id);[m
                     // Optionally mark as synced or delete from local if strict space requirements[m
                 } catch (uploadErr) {[m
                     console.error(uploadErr);[m
[1mdiff --git a/pwa/src/services/n8nService.ts b/pwa/src/services/n8nService.ts[m
[1mindex d1a2a8a..72424eb 100644[m
[1m--- a/pwa/src/services/n8nService.ts[m
[1m+++ b/pwa/src/services/n8nService.ts[m
[36m@@ -1,6 +1,5 @@[m
 export const n8nService = {[m
     webhookUrl: import.meta.env.VITE_WEBHOOK_URL || '/api/webhook/ingest-audio',[m
[31m-[m
     async uploadRecording([m
         blob: Blob,[m
         title: string,[m
[36m@@ -10,30 +9,27 @@[m [mexport const n8nService = {[m
         source: string = 'web-pwa'[m
     ): Promise<boolean> {[m
         try {[m
[31m-            const formData = new FormData();[m
[31m-            // 'data' field matches what n8n expects for binary[m
[31m-            formData.append('data', blob, `recording-${Date.now()}.webm`);[m
[31m-[m
[31m-            formData.append('title', title);[m
[31m-            formData.append('protagonist', protagonist);[m
[31m-            formData.append('language', language);[m
[31m-            formData.append('priority', priority);[m
[31m-            formData.append('source', source);[m
[31m-            formData.append('timestamp', new Date().toISOString());[m
[31m-[m
[31m-            const response = await fetch(this.webhookUrl, {[m
[32m+[m[32m            const params = new URLSearchParams({[m
[32m+[m[32m                title,[m
[32m+[m[32m                protagonist,[m
[32m+[m[32m                language,[m
[32m+[m[32m                priority,[m
[32m+[m[32m                source,[m
[32m+[m[32m                timestamp: new Date().toISOString()[m
[32m+[m[32m            });[m
[32m+[m[32m            const url = `${this.webhookUrl}?${params.toString()}`;[m
[32m+[m[32m            const response = await fetch(url, {[m
                 method: 'POST',[m
[31m-                body: formData,[m
[32m+[m[32m                headers: { 'Content-Type': 'audio/webm' },[m
[32m+[m[32m                body: blob,[m
             });[m
[31m-[m
             if (!response.ok) {[m
                 throw new Error(`Upload failed: ${response.statusText}`);[m
             }[m
[31m-[m
             return true;[m
         } catch (error) {[m
             console.error('n8n Upload Error:', error);[m
[31m-            throw error; // Let caller handle fallback to queue[m
[32m+[m[32m            throw error;[m
         }[m
     }[m
 };[m
